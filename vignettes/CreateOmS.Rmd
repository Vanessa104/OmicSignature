---
title: "Create OmicSignature"
output: rmarkdown::html_vignette
author: "Vanessa Mengze Li"
date: "03/31/2021"
vignette: >
  %\VignetteIndexEntry{Create OmicSignature}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r message=FALSE, warning=FALSE}
devtools::load_all(".")
library(dplyr)
```
<font color = "#000000">

## Create an OmicSignature Object 
An `OmicSignature` object contains three parts:  
 - **metadata**, a list contains metadata fields;  
 - **signature**, a dataframe with feature symbols and directions, and scores if applicable;  
 - **difexp**, optional, a dataframe from differential expression analysis result.  

The example provided below is from an experiment for Myc gene reduce in mice. 
Signatures was extracted by comparing the liver of treatment and control when 
mice is 24-month old. This is a bi-directional signature example, which contains 
up and down regulated features (genes).

**If you already have a .json file, you can read it in by using function `readJson()`.**  
See more in the "Functionalities, imports and exports" section. 

### Specify metadata
To be saved into a OmicSignature object, the required **metadata** fields are:  
**"signature_name", "organism", "platform", "direction_type", "phenotype"**.  
Other criteria such as adj_p (fdr corrected p-value), log fold change cutoff of 
the signature, and additional key words of the experiment will make the information more complete.  

One option is to create metadata list by hand:

```
metadata <- list(
  "signature_name" = Myc_reduce_mice_liver_24m,
  "organism" = "Mus Musculus",
  "sample_type" = "liver",
  "phenotype" = "Myc_reduce",
  "direction_type" = "bi-directional",
  "platform" = "GPL6246",
  "adj_p_cutoff" = 0.05,
  "score_cutoff" = 7,
  "keywords" = c("Myc", "KO", "longevity"),
  "PMID" = 25619689,
  "year" = 2015
)
```
Or use build-in function `createMetadata()` (recommended):
```{r}
metadata <- createMetadata(
  signature_name = "Myc_reduce_mice_liver_24m",
  organism = "Mus Musculus",
  sample_type = "liver",
  phenotype = "Myc_reduce",
  direction_type = "bi-directional",
  platform = "GPL6246",
  adj_p_cutoff = 0.05,
  score_cutoff = 7,
  keywords = c("Myc", "KO", "longevity"),
  PMID = 25619689,
  year = 2015
)
```

**If "sample_type" is NOT a BRENDA ontology term or "platform" is NOT a valid GEO platform accession ID, you will receive warnings.**  
See more info in "BRENDA ontology & GEO platform ID" section.  

#### Additional info for "direction_type"
`direction_type` is either:  
 - "uni-directional". You only have a list of significant feature names but don't know if they are up or down regulated in the treatment group, or directional infomation is not applicable.  
 - "bi-directional". In most cases significant features can be grouped into "up" and "down" regulated features. For example, when comparing treatment group with control group, some features will be higher ("up", or "+") and some will be lower ("down" or "-") in treatment.  
 - "multi-directional". Used when comparing multiple sampels together, usually using ANOVA. In this case, the "direction" column in signature table should be group name.  

#### Add more info in metadata
In this example, we are working with mouse strain C57BL/6. We can add this information into our `metadata`.  
`metadata` is just a list. Add new terms into this list like you normally do.
```{r}
metadata$"animal_strain" <- "C57BL/6"
```

### Differential expression analysis result `difexp`
A differential expression analysis matrix is **optional** but **highly recommended** if you have it.  
The differential expression analysis in this example was performed using a standard 
pipeline from lm package. Available columns are logFC, AveExpr, t score, P.Value, 
adj.P.Val, B score, Probe.ID, gene_symbol and gene_name.  

```{r}
difexp <- read.table(file.path(system.file("extdata", package = "OmicSignature"), "difmatrix_Myc_mice_liver_24m_raw.txt"),
  header = TRUE, sep = "\t", stringsAsFactors = FALSE
)
head(difexp)
```
To be saved into a OmicSignature object, the required columns for
**differential expression matrix** are:  
**"id", "symbol", "score", "adj_p"**.  
"id" is used as an unique identifier in case there are duplicated gene symbols. Frequently used id including probe ID, ENSEMBL ID, or unique numbers.  

Modify the column names to match the requirement.  
Our build-in function `replaceDifexpCol()` is designed to replace some 
frequently-used alternative column names. You can also change the column names manully.
```{r}
colnames(difexp) <- replaceDifexpCol(colnames(difexp))
head(difexp)
```


### Create signature by hand
This is a bi-directional signature example. It contains up and down regulated 
genes.  
There are multiple ways to get signatures from a differential expression 
analysis matrix. One way is to use `filter()` from `dplyr` package.  
In this example, we previously specified the `score_cutoff` and `adj_p_cutoff` 
when creating the metadata. We can use them here.
```{r}
tempUpSig <- cbind(
  filter(difexp, score > metadata$score_cutoff & adj_p < metadata$adj_p_cutoff) %>% pull(symbol),
  filter(difexp, score > metadata$score_cutoff & adj_p < metadata$adj_p_cutoff) %>% pull(score),
  "+"
)
head(tempUpSig)

tempDnSig <- cbind(
  dplyr::filter(difexp, score < (-1) * metadata$score_cutoff & adj_p < metadata$adj_p_cutoff) %>% pull(symbol),
  dplyr::filter(difexp, score < (-1) * metadata$score_cutoff & adj_p < metadata$adj_p_cutoff) %>% pull(score),
  "-"
)
head(tempDnSig)
```
(note: if you see numbers instead of gene symbol name in the first column, please check if the "symbol" column in your difexp matrix is "character" and not accidentally be "factor")  


To be stored into OmicSignature object, **signature** need to be a **dataframe** with column **"signature_symbol"**.  
If the signature is "bi-directional" or "multi-directional" (specified in 
`direction_type` in `metadata` list), then column **"signature_direction"** is 
also required. "uni-directional" type does not require this column.  
An **optional column "signature_score"** is used when feature scores are available.  

```{r}
signatures <- data.frame(rbind(tempUpSig, tempDnSig))
colnames(signatures) <- c("signature_symbol", "signature_score", "signature_direction")
```

Our function `standardizeSigDF()` can help you to remove duplicate rows, empty symbols in the signature dataframe, if any.
```{r}
signatures <- standardizeSigDF(signatures)
head(signatures)
tail(signatures)
```


### Create OmicSignature object
We have everything we need now.  
Use `OmicSignature$new()` to create a new OmicSignature R6 object.  
```{r}
OmicObj <- OmicSignature$new(
  metadata = metadata,
  signature = signatures,
  difexp = difexp
)
```

Use `print()` to see its information:
```{r}
print(OmicObj)
```

You can also ask the program to print the messages while creating the 
OmicSignature Object. By default, `print_message` is set to be `FALSE`.
```{r}
OmicObj <- OmicSignature$new(
  metadata = metadata,
  signature = signatures,
  difexp = difexp,
  print_message = TRUE
)
```


## Create OmicSignature from difexp and metadata
You can also by-pass the generating signature process. Instead, simply provide 
cutoffs in metadata, and use `OmicSigFromDifexp()` function to extract 
signatures from difexp according to those criteria. 
```{r}
OmicObj1 <- OmicSigFromDifexp(difexp, metadata)
```

It gives the same signature as we did by hand before. See the top signatures: 
```{r}
head(OmicObj1$signature %>% dplyr::arrange(desc(abs(signature_score))))
dim(OmicObj1$signature)
```

```{r}
head(OmicObj$signature %>% dplyr::arrange(desc(abs(signature_score))))
dim(OmicObj$signature)
```

</font>
--
